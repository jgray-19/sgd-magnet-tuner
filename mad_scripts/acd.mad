local twopi in MAD.constant
local abs, sin, max, sqrt in math
local volt_factor = 0.042
    
local function get_acd_slice_action(elm, pbeam, tunes, drv_tunes, betas, ramp)
    -- The settings for the AC dipole
    local voltx = volt_factor * pbeam * abs(tunes[1] - drv_tunes[1]) / sqrt(180.0 * betas[1])
    local volty = volt_factor * pbeam * abs(tunes[2] - drv_tunes[2]) / sqrt(177.0 * betas[2])
    
    local omegax = twopi * drv_tunes[1]
    local omegay = twopi * drv_tunes[2]
    local vrfx  = 0.3 * voltx / pbeam
    local vrfy  = 0.3 * volty / pbeam
    local atslice
    local prev_turn = -1
    print(elm.l)
    io.read()
    if ramp then
        print("AC dipole: ramp", ramp[1], ramp[2], ramp[3], ramp[4])
        -- The AC dipole function
        atslice = \a, mflw, c, d =>
            local turn in mflw -- Note: turn starts at 1 (does MAD-X start at 0? - if so, change the following lines)
            if turn == prev_turn then return end
            prev_turn = turn
            madx_turn = turn-1

            print("New turn, updating acd", turn)
            local mult
            if madx_turn < ramp[1] then -- This is how many turns before the ramp starts
                mult = 0
            elseif madx_turn < ramp[2] then -- This is how long the ramp up is
                mult = (madx_turn - ramp[1]) / (ramp[2] - ramp[1])
            elseif madx_turn < ramp[3] then -- This is the flat top
                mult = 1
            elseif madx_turn < ramp[4] then -- This is the ramp down
                mult = (ramp[4] - madx_turn) / (ramp[4] - ramp[3])
            else
                mult = 0
            end
            print("hkick", vrfx * mult * sin(omegax * (madx_turn)))
            print("vkick", vrfy * mult * sin(omegay * (madx_turn)))
            elm.hkick = vrfx * mult * sin(omegax * (madx_turn)) !/ elm.l
            elm.vkick = vrfy * mult * sin(omegay * (madx_turn)) !/ elm.l
        end
    else
        print("AC dipole: no ramp")
        atslice = \_, mflw, _, _ =>
            local turn in mflw -- Note: turn starts at 1 (does MAD-X start at 0? - if so, change the following lines)
            if turn == prev_turn then return end
            prev_turn = turn
            elm.hkick = vrfx * sin(omegax * (turn)) -- Note: turn starts at 1 (Change if MAD-X starts at 0)
            elm.vkick = vrfy * sin(omegay * (turn)) -- Note: turn starts at 1 (Change if MAD-X starts at 0)
        end
    end
    return atslice  
end
return get_acd_slice_action
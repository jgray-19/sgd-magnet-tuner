! run_optics_track_init.mad

num_knobs = #knob_names
local twopi in MAD.constant
local atan2 in MAD.gmath

function extract_phase_from_map(map, plane)
    -- Extract phase from damap: phase = atan2(a12, a11) / 2π
    -- For x plane: v=1 (a11 = map[1]:get("100000"), a12 = map[1]:get("010000"))
    -- For y plane: v=3 (a11 = map[3]:get("001000"), a12 = map[3]:get("000100"))
    local a11 = map[plane]:get(orbit_deriv_key[plane])
    local a12 = map[plane]:get(momentum_deriv_key[plane])
    return atan2(a12, a11) / twopi
end

function extract_beta_from_map(map, plane)
    -- Extract beta from damap: beta = a11^2 + a12^2
    local a11 = map[plane]:get(orbit_deriv_key[plane])
    local a12 = map[plane]:get(momentum_deriv_key[plane])
    return a11^2 + a12^2
end

orbit_deriv_key = {x = "100000", y = "001000"}
momentum_deriv_key = {x = "010000", y = "000100"}
x_derivative_wrt_knob_keys = {x = {}, y = {}}
px_derivative_wrt_knob_keys = {x = {}, y = {}}

-- Precompute the suffixes for knob derivatives
local knob_suffixes = {}
for k=1,num_knobs do
    knob_suffixes[k] = string.rep("0", k - 1) .. "1"
end

for _, plane in ipairs{"x", "y"} do
    for k=1,num_knobs do
        x_derivative_wrt_knob_keys[plane][k] = monomial(orbit_deriv_key[plane] .. knob_suffixes[k])
        px_derivative_wrt_knob_keys[plane][k] = monomial(momentum_deriv_key[plane] .. knob_suffixes[k])
    end
end

function derivative_beta_wrt_knob(map, plane)
    fx_x = map[plane]:get(orbit_deriv_key[plane])
    fx_px = map[plane]:get(momentum_deriv_key[plane])

    fx_xk = vector(num_knobs)
    fx_pxk = vector(num_knobs)

    for k=1,num_knobs do
        fx_xk:seti(k, map[plane]:get(x_derivative_wrt_knob_keys[plane][k]))
        fx_pxk:seti(k, map[plane]:get(px_derivative_wrt_knob_keys[plane][k]))
    end

    return 2 * (fx_x * fx_xk + fx_px * fx_pxk)
end

function derivative_phase_wrt_knob(map, plane)
    -- Derivative of phase: dφ/dk = (1/2π) * (a11 * da12/dk - a12 * da11/dk) / (a11² + a12²)
    local a11 = map[plane]:get(orbit_deriv_key[plane])
    local a12 = map[plane]:get(momentum_deriv_key[plane])

    local da11_dk = vector(num_knobs)
    local da12_dk = vector(num_knobs)

    for k=1,num_knobs do
        da11_dk:seti(k, map[plane]:get(x_derivative_wrt_knob_keys[plane][k]))
        da12_dk:seti(k, map[plane]:get(px_derivative_wrt_knob_keys[plane][k]))
    end

    local beta = a11^2 + a12^2
    return (a11 * da12_dk - a12 * da11_dk) / beta / twopi
end

function derivative_phase_advance_wrt_knob(prev_map, curr_map, plane)
    -- Derivative of phase advance between two BPMs: d(φ_curr - φ_prev)/dk
    local dphase_curr_dk = derivative_phase_wrt_knob(curr_map, plane)
    local dphase_prev_dk = derivative_phase_wrt_knob(prev_map, plane)
    return dphase_curr_dk - dphase_prev_dk
end

! function derivative_alfa_wrt_knob(map, plane)
!     mom = "p" .. plane
!     fx_x = map[plane]:get(orbit_deriv_key[plane])
!     fpx_x = map[mom]:get(orbit_deriv_key[plane])

!     fx_px = map[plane]:get(momentum_deriv_key[plane])
!     fpx_px = map[mom]:get(momentum_deriv_key[plane])

!     fx_xk = vector(num_knobs)
!     fpx_xk = vector(num_knobs)
!     fx_pxk = vector(num_knobs)
!     fpx_pxk = vector(num_knobs)

!     for k=1,num_knobs do
!         fx_xk:seti(k, map[plane]:get(x_derivative_wrt_knob_keys[plane][k]))
!         fpx_xk:seti(k, map[mom]:get(x_derivative_wrt_knob_keys[plane][k]))

!         fx_pxk:seti(k, map[plane]:get(px_derivative_wrt_knob_keys[plane][k]))
!         fpx_pxk:seti(k, map[mom]:get(px_derivative_wrt_knob_keys[plane][k]))
!     end

!     return -1 * (fpx_x * fx_xk + fpx_x * fx_xk + fpx_px * fx_pxk + fx_px * fpx_pxk)
! end


betx = vector(nbpms)
bety = vector(nbpms)
! alfx = vector(nbpms)
! alfy = vector(nbpms)

-- Phase advances between consecutive BPMs (nbpms-1 values)
phase_adv_x = vector(nbpms - 1)
phase_adv_y = vector(nbpms - 1)

derivative_beta_x_wrt_knob = matrix(nbpms, num_knobs)
derivative_beta_y_wrt_knob = matrix(nbpms, num_knobs)
! derivative_alfa_x_wrt_knob = matrix(nbpms, num_knobs)
! derivative_alfa_y_wrt_knob = matrix(nbpms, num_knobs)

-- Derivatives of phase advances (nbpms-1 rows)
derivative_phase_adv_x_wrt_knob = matrix(nbpms - 1, num_knobs)
derivative_phase_adv_y_wrt_knob = matrix(nbpms - 1, num_knobs)

-- Storage for previous BPM's map
prev_map = false

observation_index = nbpms + 1  ! Start beyond the last bpm to ensure reset is called before tracking
function save_data(elm, mflw, _, slc)
    -- Observe the BPMs at the specified intervals
    ! We don't care about forward or backward slices here as we assume the observation points are BPMs and have no effect on the physics
    if slc == -2 and elm:is_observed() then
        local curr_map = mflw[1]  -- Use first particle's map for optics -> only 1 particle needed

        -- Compute beta functions at current BPM
        local beta_x = extract_beta_from_map(curr_map, "x")
        local beta_y = extract_beta_from_map(curr_map, "y")
        betx:seti(observation_index, beta_x)
        bety:seti(observation_index, beta_y)

        -- Compute derivatives of beta functions
        derivative_beta_x_wrt_knob:setrow(observation_index, derivative_beta_wrt_knob(curr_map, "x"))
        derivative_beta_y_wrt_knob:setrow(observation_index, derivative_beta_wrt_knob(curr_map, "y"))

        if prev_map then
            -- Compute phase advance between previous and current BPM
            local phase_x_prev = extract_phase_from_map(prev_map, "x")
            local phase_y_prev = extract_phase_from_map(prev_map, "y")
            local phase_x_curr = extract_phase_from_map(curr_map, "x")
            local phase_y_curr = extract_phase_from_map(curr_map, "y")

            local phase_advance_x = (phase_x_curr - phase_x_prev)
            local phase_advance_y = (phase_y_curr - phase_y_prev)

            -- Store phase advance (observation_index-1 because first BPM has no advance)
            phase_adv_x:seti(observation_index - 1, phase_advance_x)
            phase_adv_y:seti(observation_index - 1, phase_advance_y)

            -- Compute and store derivatives of phase advance
            derivative_phase_adv_x_wrt_knob:setrow(
                observation_index - 1,
                derivative_phase_advance_wrt_knob(prev_map, curr_map, "x")
            )
            derivative_phase_adv_y_wrt_knob:setrow(
                observation_index - 1,
                derivative_phase_advance_wrt_knob(prev_map, curr_map, "y")
            )
        end

        -- Store current map for next iteration
        prev_map = curr_map:copy()

        -- Increment the index for the next bpm
        observation_index = observation_index + 1
    end
end

function reset_before_tracking()
    !assert(observation_index == nbpms + 1, "Not all BPMs observed before resetting, got " .. observation_index - 1 .. ", expected " .. nbpms)
    observation_index = 1
    prev_map = false

    betx:zeros()
    bety:zeros()
    ! alfx:zeros()
    ! alfy:zeros()
    phase_adv_x:zeros()
    phase_adv_y:zeros()

    derivative_beta_x_wrt_knob:zeros()
    derivative_beta_y_wrt_knob:zeros()
    ! derivative_alfa_x_wrt_knob:zeros()
    ! derivative_alfa_y_wrt_knob:zeros()
    derivative_phase_adv_x_wrt_knob:zeros()
    derivative_phase_adv_y_wrt_knob:zeros()
end
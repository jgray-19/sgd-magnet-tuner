! run_track_init.mad

! Assumes the following variables are defined:
! loaded_sequence: the sequence to be used for tracking
! batch_size: a table with the number of particles for each starting bpm
! nbpms: the number of BPMs to track
! knob_names: a table with the names of the knobs
! vector: a MAD vector object for creating vectors
! matrix: a MAD matrix object for creating matrices
! py: a Python interface object for sending data

assert(
    batch_size and nbpms and
    vector and matrix and py and n_compare_turns,
    "Missing required variables for initialising"
)

! Create tables to hold the x, y, dx_dk, and dy_dk data for each particle.
! Specifying how many indexable slots we want in each table. (lujit)
x = table.new(batch_size, 0)
y = table.new(batch_size, 0)
dx_dk = table.new(batch_size, 0)
dy_dk = table.new(batch_size, 0)

for i=1,batch_size do
    x[i] = vector(nbpms*n_compare_turns)
    y[i] = vector(nbpms*n_compare_turns)
    dx_dk[i] = matrix(1, nbpms*n_compare_turns)
    dy_dk[i] = matrix(1, nbpms*n_compare_turns)
end

observe_count = 1
function save_data(elm, mflw, _, slc)
    local turn in mflw
    -- Observe the BPMs at the specified intervals
    if slc == -2 and elm:is_observed() and turn >= mflw.observe then
         -- Loop over each particle in the batch
        for i=1,batch_size do
            x[i]:seti(observe_count, mflw[i].x:get0()) ! get0 returns the scalar
            y[i]:seti(observe_count, mflw[i].y:get0()) ! get0 returns the scalar
            dx_dk[i]:setsub(1, observe_count, mflw[i].x:get(7)) ! Set dx_dpt
            dy_dk[i]:setsub(1, observe_count, mflw[i].y:get(7)) ! Set dy_dpt
        end
        -- Increment the index for the next bpm
        observe_count = observe_count + 1
    end
end

function reset_before_tracking()
    observe_count = 1
    for i=1,batch_size do
        x[i]:zeros()
        y[i]:zeros()
        dx_dk[i]:zeros()
        dy_dk[i]:zeros()
    end
end
! run_track_init_no_knobs.mad

! Assumes the following variables are defined:
! loaded_sequence: the sequence to be used for tracking
! batch_size: a table with the number of particles for each starting bpm
! nbpms: the number of BPMs to track
! knob_names: a table with the names of the knobs
! vector: a MAD vector object for creating vectors
! matrix: a MAD matrix object for creating matrices
! python: a Python interface object for sending data

assert(
    batch_size and nbpms and knob_monomials and
    knob_names and vector and matrix and python,
    "Missing required variables for initialising"
)

! Create tables to hold the x, y, dx_dk, and dy_dk data for each particle.
! Specifying how many indexable slots we want in each table. (lujit)
x = table.new(batch_size, 0)
y = table.new(batch_size, 0)
px = table.new(batch_size, 0)
py = table.new(batch_size, 0)
dx_dk = table.new(batch_size, 0)
dy_dk = table.new(batch_size, 0)
dpx_dk = table.new(batch_size, 0)
dpy_dk = table.new(batch_size, 0)

for i=1,batch_size do
    x[i] = vector(nbpms)
    y[i] = vector(nbpms)
    px[i] = vector(nbpms)
    py[i] = vector(nbpms)
    dx_dk[i] = matrix(1, nbpms)
    dy_dk[i] = matrix(1, nbpms)
    dpx_dk[i] = matrix(1, nbpms)
    dpy_dk[i] = matrix(1, nbpms)
end

observe_count = nbpms + 1  ! Start beyond the last bpm to ensure reset is called before tracking
function save_data(elm, mflw, _, slc)
    local turn in mflw
    -- Observe the BPMs at the specified intervals
    if slc == -2 and elm:is_observed() then
         -- Loop over each particle in the batch
        for i=1,batch_size do
            x[i]:seti(observe_count, mflw[i].x:get0()) ! get0 returns the scalar
            y[i]:seti(observe_count, mflw[i].y:get0()) ! get0 returns the scalar
            px[i]:seti(observe_count, mflw[i].px:get0()) ! get0 returns the scalar
            py[i]:seti(observe_count, mflw[i].py:get0()) ! get0 returns the scalar

            dx_dk[i]:setsub(1, observe_count, mflw[i].x:get(7)) ! Set dx_dpt
            dy_dk[i]:setsub(1, observe_count, mflw[i].y:get(7)) ! Set dy_dpt
            dpx_dk[i]:setsub(1, observe_count, mflw[i].px:get(7)) ! Set dpx_dpt
            dpy_dk[i]:setsub(1, observe_count, mflw[i].py:get(7)) ! Set dpy_dpt
        end
        -- Increment the index for the next bpm
        observe_count = observe_count + 1
    end
end

function reset_before_tracking()
    assert(observe_count == nbpms + 1, "Not all BPMs observed before resetting, got " .. observe_count - 1 .. ", expected " .. nbpms)
    observe_count = 1
    for i=1,batch_size do
        x[i]:zeros()
        y[i]:zeros()
        px[i]:zeros()
        py[i]:zeros()
        dx_dk[i]:zeros()
        dy_dk[i]:zeros()
        dpx_dk[i]:zeros()
        dpy_dk[i]:zeros()
    end
    print("Reset data tables for new tracking")
end
! run_track_init.mad

! Assumes the following variables are defined:
! loaded_sequence: the sequence to be used for tracking
! batch_size: a table with the number of particles for each starting bpm
! nbpms: the number of BPMs to track
! knob_names: a table with the names of the knobs
! vector: a MAD vector object for creating vectors
! matrix: a MAD matrix object for creating matrices
! python: a Python interface object for sending data

assert(
    batch_size and nbpms and knob_monomials and
    knob_names and vector and matrix and python,
    "Missing required variables for initialising"
)

num_knobs = #knob_names ! Includes dpp
local set_range = vector(num_knobs):seq() ! I want to set 1 to num_knobs (without dpp)
! I want to get 7 to 7 + num_knobs. idx 1 is the scalar. idx 2 - 7 is dx/dx, dx/px, dx/dy, dx/dpy, dx/dt, dx/dpt
local get_range = vector(num_knobs):seq(7)

! Create tables to hold the x, y, dx_dk, and dy_dk data for each particle.
! Specifying how many indexable slots we want in each table. (lujit)
x = table.new(batch_size, 0)
y = table.new(batch_size, 0)
px = table.new(batch_size, 0)
py = table.new(batch_size, 0)
dx_dk = table.new(batch_size, 0)
dy_dk = table.new(batch_size, 0)
dpx_dk = table.new(batch_size, 0)
dpy_dk = table.new(batch_size, 0)

for i=1,batch_size do
    x[i] = vector(nbpms)
    y[i] = vector(nbpms)
    px[i] = vector(nbpms)
    py[i] = vector(nbpms)
    dx_dk[i] = matrix(num_knobs+1, nbpms)
    dy_dk[i] = matrix(num_knobs+1, nbpms)
    dpx_dk[i] = matrix(num_knobs+1, nbpms)
    dpy_dk[i] = matrix(num_knobs+1, nbpms)
end

local function get_knob_vec(xy_tpsa)
    local all_first_deriv = xy_tpsa:getvec(1, num_knobs + 7)
    return all_first_deriv:getvec(get_range) ! Remove 0, dx, dpx, dy, dpy, dt, dpt
    -- local vector_result = vector(num_knobs)
    -- for i, name in ipairs(knob_names) do
    --     vector_result:seti(i, xy_tpsa:get(knob_monomials[name]))
    -- end
    -- return vector_result
end

observe_count = nbpms + 1  ! Start beyond the last bpm to ensure reset is called before tracking
function save_data(elm, mflw, _, slc)
    local turn in mflw
    -- Observe the BPMs at the specified intervals
    -- if elm:is_observed() then
    --     print(slc) end
    if slc == -2 and elm:is_observed() then
        -- print(elm.name .. ": Observing at turn " .. turn .. ", index " .. observe_count)
         -- Loop over each particle in the batch
        for i=1,batch_size do
            x[i]:seti(observe_count, mflw[i].x:get0()) ! get0 returns the scalar
            y[i]:seti(observe_count, mflw[i].y:get0()) ! get0 returns the scalar
            px[i]:seti(observe_count, mflw[i].px:get0()) ! get0 returns the scalar
            py[i]:seti(observe_count, mflw[i].py:get0()) ! get0 returns the scalar

            dx_dk[i] :setsub(set_range, observe_count, get_knob_vec(mflw[i].x))
            dy_dk[i] :setsub(set_range, observe_count, get_knob_vec(mflw[i].y))
            dpx_dk[i]:setsub(set_range, observe_count, get_knob_vec(mflw[i].px))
            dpy_dk[i]:setsub(set_range, observe_count, get_knob_vec(mflw[i].py))

            dx_dk[i]:setsub(num_knobs+1, observe_count, mflw[i].x:get(7)) ! Set dx_dpt
            dy_dk[i]:setsub(num_knobs+1, observe_count, mflw[i].y:get(7)) ! Set dy_dpt
            dpx_dk[i]:setsub(num_knobs+1, observe_count, mflw[i].px:get(7)) ! Set dpx_dpt
            dpy_dk[i]:setsub(num_knobs+1, observe_count, mflw[i].py:get(7)) ! Set dpy_dpt
        end
        -- Increment the index for the next bpm
        observe_count = observe_count + 1
    end
end

function reset_before_tracking()
    assert(observe_count == nbpms + 1, "Not all BPMs observed before resetting, got " .. observe_count - 1 .. ", expected " .. nbpms)
    observe_count = 1
    for i=1,batch_size do
        x[i]:zeros()
        y[i]:zeros()
        px[i]:zeros()
        py[i]:zeros()
        dx_dk[i]:zeros()
        dy_dk[i]:zeros()
        dpx_dk[i]:zeros()
        dpy_dk[i]:zeros()
    end
end
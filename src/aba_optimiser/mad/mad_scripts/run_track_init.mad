! run_track_init.mad

! Assumes the following variables are defined:
! loaded_sequence: the sequence to be used for tracking
! batch_size: a table with the number of particles for each starting bpm
! nbpms: the number of BPMs to track
! knob_names: a table with the names of the knobs
! vector: a MAD vector object for creating vectors
! matrix: a MAD matrix object for creating matrices
! python: a Python interface object for sending data

assert(
    batch_size and nbpms and knob_monomials and
    knob_names and vector and matrix and python,
    "Missing required variables for initialising"
)

num_knobs = #knob_names ! Number of magnet knobs
local matrix_size = optimise_energy and (num_knobs + 1) or num_knobs

! Have the set and get ranges in this scope to prevent errors in the save_data function
local set_range, get_range, get_knob_vec

! Only define these if there are knobs to optimise
if num_knobs > 0 then
    set_range = vector(num_knobs):seq() ! I want to set 1 to num_knobs (without dpp)
    ! I want to get 7 to 7 + num_knobs. idx 1 is the scalar. idx 2 - 7 is dx/dx, dx/px, dx/dy, dx/dpy, dx/dt, dx/dpt
    get_range = vector(num_knobs):seq(7)

    function get_knob_vec(xy_tpsa)
        local all_first_deriv = xy_tpsa:getvec(1, num_knobs + 7)
        return all_first_deriv:getvec(get_range) ! Remove 0, dx, dpx, dy, dpy, dt, dpt
    end
end

! Create tables to hold the x, y, dx_dk, and dy_dk data for each particle.
! Specifying how many indexable slots we want in each table. (lujit)
x = table.new(batch_size, 0)
y = table.new(batch_size, 0)
px = table.new(batch_size, 0)
py = table.new(batch_size, 0)
dx_dk = table.new(batch_size, 0)
dy_dk = table.new(batch_size, 0)
dpx_dk = table.new(batch_size, 0)
dpy_dk = table.new(batch_size, 0)

for i=1,batch_size do
    x[i] = vector(nbpms)
    y[i] = vector(nbpms)
    px[i] = vector(nbpms)
    py[i] = vector(nbpms)
    dx_dk[i] = matrix(matrix_size, nbpms)
    dy_dk[i] = matrix(matrix_size, nbpms)
    dpx_dk[i] = matrix(matrix_size, nbpms)
    dpy_dk[i] = matrix(matrix_size, nbpms)
end

observe_count = nbpms + 1  ! Start beyond the last bpm to ensure reset is called before tracking
function save_data(elm, mflw, _, slc)
    local turn in mflw
    -- Observe the BPMs at the specified intervals
    if slc == -2 and elm:is_observed() then
         -- Loop over each particle in the batch
        for i=1,batch_size do
            x[i]:seti(observe_count, mflw[i].x:get0()) ! get0 returns the scalar
            y[i]:seti(observe_count, mflw[i].y:get0()) ! get0 returns the scalar
            px[i]:seti(observe_count, mflw[i].px:get0()) ! get0 returns the scalar
            py[i]:seti(observe_count, mflw[i].py:get0()) ! get0 returns the scalar

            if set_range then ! If set_range is defined (i.e. num_knobs > 0)
                dx_dk[i] :setsub(set_range, observe_count, get_knob_vec(mflw[i].x))
                dy_dk[i] :setsub(set_range, observe_count, get_knob_vec(mflw[i].y))
                dpx_dk[i]:setsub(set_range, observe_count, get_knob_vec(mflw[i].px))
                dpy_dk[i]:setsub(set_range, observe_count, get_knob_vec(mflw[i].py))
            end

            if optimise_energy then
                local dpt_idx = num_knobs + 1
                dx_dk[i]:setsub(dpt_idx, observe_count, mflw[i].x:get(7)) ! Set dx_dpt
                dy_dk[i]:setsub(dpt_idx, observe_count, mflw[i].y:get(7)) ! Set dy_dpt
                dpx_dk[i]:setsub(dpt_idx, observe_count, mflw[i].px:get(7)) ! Set dpx_dpt
                dpy_dk[i]:setsub(dpt_idx, observe_count, mflw[i].py:get(7)) ! Set dpy_dpt
            end
        end
        -- Increment the index for the next bpm
        observe_count = observe_count + 1
    end
end

function reset_before_tracking()
    ! assert(observe_count == nbpms + 1, "Not all BPMs observed before resetting, got " .. observe_count - 1 .. ", expected " .. nbpms)
    observe_count = 1
    for i=1,batch_size do
        x[i]:zeros()
        y[i]:zeros()
        px[i]:zeros()
        py[i]:zeros()
        dx_dk[i]:zeros()
        dy_dk[i]:zeros()
        dpx_dk[i]:zeros()
        dpy_dk[i]:zeros()
    end
end